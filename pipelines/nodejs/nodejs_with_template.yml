apiVersion: v1
kind: Template
metadata:
  name: nodejs-pipeline
parameters:
  - name: NAME
    description: The name assigned to all of the frontend objects defined in this template.
    displayName: Name
    required: true
    value:
  - name: IMAGE_VERSION
    displayName: Version(TAG) of Entando's NodeJs Image
    description: Version of NodeJS image to be used (master).
    value: master
    required: true
  - name: MEMORY_LIMIT
    displayName: Memory Limit
    description: Maximum amount of memory the container cau use.
    required: true
    value: "512Mi"
  - name: SOURCE_REPOSITORY_URL
    displayName: Git repository URL
    description: The URL of the repository containing the application source code.
    required: true
    value:
  - name: SOURCE_REPOSITORY_REF
    displayName: Git reference
    description: Set this to a branch name, tag or other ref of your repository if you are not using the default branch.
    value: master
  - name: CONTEXT_DIR
    displayName: Context directory
    desctiprion: Set this to the relative path of the root directory of your project.
    value:
  - name: APPLICATION_DOMAIN
    displayName: Application hostname
    desctription: The exposed hostname that will route to the Node.js service. If left blank a value will be defaulted.
    value:
  - name: GITHUB_WEBHOOK_SECRET
    displayName: GitHub Webhook secret
    description: Github trigger secret. A difficult to guess string encoded as part ot the webhook URL. Not encrypted.
    from: '[a-zA-Z0-9]{40}'
    generate: expression
    required: true
  - name: GENERIC_WEBHOOK_SECRET
    displayName: Generic webhook secret
    description: A secret string used to configure the Generic webhook.
    from: '[a-zA-Z0-9]{40}'
    generate: expression
  - name: NPM_MIRROR
    displayName: Custom NPM mirror URL
    description: Your custom NPM mirror URL
  - name: REACT_APP_USE_MOCKS
    displayName: Use mocks data. Default is false.
    description: Decide if use mocks data or not. (Accepted values are false[default], true).
    required: true
    value: false
  - name: REACT_APP_DOMAIN
    displayName: Entando engine-api URL to call
    description: URI of the entando engine-api instance to call.
    required: true
    value: https://pwa-provider.127.0.0.1.nip-io/pwa-provider
  - name: REACT_APP_CLIENT_ID
    displayName: Authorized clientID
    description: Authorized clientID to make requests against entando engine-api instance.
    required: true
    value: appbuilder
  - name: REACT_APP_CLIENT_SECRET
    displayName: Client secret
    description: Client secret to use against entando engine-api instance.
    required: true
    value: appbuilde_secret
  - name: REACT_APP_DEMO_USERNAME
    displayName: Entando engine-api authorized username
    description: Entando's engine-api authorized username.
    required: true
    value: admin
  - name: REACT_APP_DEMO_PASSWORD
    displayName: Entando engine-api demo username password
    description: Entando's engine-api demo username password.
    required: true
    value: adminadmin
objects:
  - apiVersion: v1
    kind: ImageStream
    metadata:
      labels:
        app: ${APP_NAME}
      name: ${APP_NAME}
    spec: {}
    status:
      dockerImageRepository: ""
  - apiVersion: v1
    kind: ImageStream
    metadata:
      name: pwa
    spec:
      tags:
        - annotations:
            supports: nodejs, react npm
            tags: builder, nodejs, react, npm
            version: "1.0"
          from:
            kind: DockerImage
            name: entando/eap-nodejs-openshift:${IMAGE_VERSION}
          name: "1.0"
        - annotations:
            supports: nodejs, react, npm
            tags: builder, nodejs, react, npm
          from:
            kind: ImageStreamTag
            name: "1.0"
          name: latest
  - apiVersion: v1
    kind: "BuildConfig"
    metadata:
      annotations:
        pipeline.alpha.openshift.io/uses: '[{"name": "${NAME}", "namespace": "", "kind": "DeploymentConfig"}]'
      creationTimestamp: null
      labels:
        name: ${APP_NAME}
      name: ${APP_NAME}
    spec:
      strategy:
        jenkinsPipelineStrategy:
          jenkinsfile: |-
            try {
                timeout(time: 20, unit: 'MINUTES') {

                    // path of the template to use
                    def templatePath = 'https://raw.githubusercontent.com/entando/openshift-templates/master/templates/nodejs/pwa-shell/pwa-shell.json'
                    // name of the template that will be created
                    def templateName = 'pwa-shell'
                    // NOTE, the "pipeline" directive/closure from the declarative pipeline syntax needs to include, or be nested outside,
                    // and "openshift" directive/closure from the OpenShift Client Plugin for Jenkins.  Otherwise, the declarative pipeline engine
                    // will not be fully engaged.
                    pipeline {
                        agent {
                          node {
                            // spin up a node.js slave pod to run this build on
                            label 'nodejs'
                          }
                        }
                        options {
                            // set a timeout of 20 minutes for this pipeline
                            timeout(time: 20, unit: 'MINUTES')
                        }

                        stages {
                            stage('preamble') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                echo "Using project: ${openshift.project()}"
                                            }
                                        }
                                    }
                                }
                            }
                            stage('cleanup') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                // delete everything with this template label
                                                openshift.selector("all", [ template : templateName ]).delete()
                                                // delete any secrets with this template label
                                                if (openshift.selector("secrets", templateName).exists()) {
                                                    openshift.selector("secrets", templateName).delete()
                                                }
                                            }
                                        }
                                    } // script
                                } // steps
                            } // stage
                            stage('create') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                // create a new application from the templatePath
                                                openshift.newApp(templatePath)
                                            }
                                        }
                                    } // script
                                } // steps
                            } // stage
                            stage('build') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                def builds = openshift.selector("bc", templateName).related('builds')
                                                builds.untilEach(1) {
                                                    return it.object().status.phase == "Complete"
                                                }
                                            }
                                        }
                                    } // script
                                } // steps
                            } // stage
                            stage('deploy') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                def rm = openshift.selector("dc", templateName).rollout()
                                                openshift.selector("dc", templateName).related('pods').untilEach(1) {
                                                    return (it.object().status.phase == "Running")
                                                }
                                            }
                                        }
                                    } // script
                                } // steps
                            } // stage
                            stage('tag') {
                                steps {
                                    script {
                                        openshift.withCluster() {
                                            openshift.withProject() {
                                                // if everything else succeeded, tag the ${templateName}:latest image as ${templateName}-staging:latest
                                                // a pipeline build config for the staging environment can watch for the ${templateName}-staging:latest
                                                // image to change and then deploy it to the staging environment
                                                openshift.tag("${templateName}:latest", "${templateName}-staging:latest")
                                            }
                                        }
                                    } // script
                                } // steps
                            } // stage
                        } // stages
                    } // pipeline
                } catch (err) {
                    echo "in catch block"
                    echo "Caught: ${err}"
                    currentBuild.result = "FAILURE'
                    throw err
                }
        type: JenkinsPipeline
      triggers:
        - github:
            secret: "${GITHUB_WEBHOOK_SECRET}"
          type: Github
        - generic:
            secret: "${GENERIC_WEBHOOK_SECRET}"
          type: Generic
  - apiVersion: v1
    kind: BuildConfig
    metadata:
      labels:
        app: ${APP_NAME}-docker
      name: ${APP_NAME}-docker
    spec:
      output:
        to:
          kind: ImageStreamTag
          name: ${APP_NAME}:latest
      postCommit: {}
      resources: {}
      runPolicy: Serial
      source:
        dockerfile: |-
